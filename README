数据类型
==========

整数
----------

int8,  byte  - 1字节，有符号整数
int16, short - 2字节，有符号整数
int32, int   - 4字节，有符号整数
int64, long  - 8字节，有符号整数

uint8,  ubyte  - 1字节，无符号整数
uint16, ushort - 
uint32, uint   - 
uint64, ulong  -

字符串
----------

字符串头部始终包含一个无符号整数类型的长度信息，空字符串的长度为0。

string8, string  - 长度信息占用1个字节
string16         - 长度信息占用2个字节
string32         - 长度信息占用4个字节
string64         - 长度信息占用8个字节

列表
----------

列表头部包含一个无符号整数类型的列表长度信息，空列表的长度为0。

list8, list  - 长度信息占用1个字节
list16       - 长度信息占用2个字节
list32       - 长度信息占用4个字节
list64       - 长度信息占用8个字节

枚举
----------

与C语言不一样，枚举声明必须有值和值类型

enum

文档格式
==========

包和定义
----------

包就像C++里的命名空间，本身并没有业务逻辑含义只起到组织代码的走用。
BS中的包以 pkg 关键字声明，顶级包（第一级）除了包名称外还需要显式指定包ID。
包ID在序列化时使用1个字节的无符号整数表示，所以允许的包ID范围为0 ~ 255。

定义就像C++中的类或者结构体，起到描述数据结构的作用。
BS中的定义使用 def 关键字，每个定义除了名称外还需要指定一个ID。
定义ID与包ID一样都是用1个字节的无符号整数表示，所以允许的定义ID范围为0~255。
不同包里面的定义ID以及名称允许重复，但是同一个包的定义名称和ID必须唯一。

所以，BS允许最大255个包，每个包最多允许有255个定义。

示例1：

    pkg player = 1
    {
      enum login_state
      { 
        INIT    = 0,
        FAILED  = 1,
        SUCCEED = 2
      }

      def login_params = 0
      {
        user_name  : string,
        hash_code  : string,
        login_time : int
      }

      def login_result = 1
      {
        state : enum<login_state>
      }
    }

包可以嵌套定义，目的是更灵活的组织代码，比如登录接口有上下行数据，
按示例1那样分开声明没有问题，但是显得分散不利于阅读。可以尝试像示例2一样组织代码。

示例2:

    pkg player = 1
    {
      pkg login
      {
        enum state
        { 
          INIT    = 0, 
          FAILED  = 1,
          SUCCEED = 2
        }

        def in = 0
        {
          user_name  : string,
          hash_code  : string,
          login_time : int
        }

        def out = 1
        {
          state : enum<state>
        }
      }
    }

具体的组织方式应该根据自身项目特点决定，并没有绝对的好坏。但是建议每个项目
只按一种规则书写BS代码，这是从工程化角度出发。

注释
----------

BS的注释有严格的书写位置要求，不能随意书写。

对于包和定义的注释，一定要写前面，对于字段的注释一定要写在后面。
