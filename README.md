BinSpec是什么？
==========

BinSpec是Binary Specification的缩写以下简称BS，这个项目的目标是创建
一个描述二进制数据结构的语言。创建它的最初目的是描述二进制通讯协议，
但是你同样可以用它来制作二进制序列化存储的工具。  

它足够简单不会对开发人员造成额外的学习负担，因为它的目的就在于描述
数据结构，所以比起XML等非专门性语言，它不会有冗余的结构，这使得文档
易于阅读和维护。

BinSpec怎么用？
==========

BS自身只提供了一套语言规范和一个用于解析BS文档的命令行程序，它不对
使用场景做过多的假设，它只做一些最基本的约束。如何发挥大部分取决于你
如何使用。

不管如何使用，首先你需要将你的通讯协议等二进制数据结构用BS语法描述出
来，这个过程就像在设计一些C语言的结构体。  

BS通过解析和翻译你所编写的文档，将数据结构描述信息转换成PHP可以理解
的数据。BS生成PHP，但并不负责生成项目所需的代码。你可以将BS理解为一个
“生成代码生成器的生成器”，它只是将BS文档转换成PHP里的一组对象。你还
需要编写一套对应自己项目需求的代码生成模版，才能真正发挥BS的威力。  

比如你将项目的通讯协议写成BS文档，BS始终会将它转换成PHP中的bs\_get\_doc函数，
你的模版通过调用这个函数就可以得到通讯协议的所有信息，接着你就可以利用
这些信息生成客户端代码、服务端代码、或者别的什么，甚至你乐意的话可以直接就
利用这些信息启动一个Socket服务器。  

典型的BS命令行执行方式会像这样：

    ./bs -c protocals.bs template.php | php

BS自身生成PHP代码，但是不负责理解和执行它，它只是输出到命令行的标准输出
需要的时候可以利用shell的管道语法将输出转给php执行或者用重定向语法保持内容
这个设计让BS保持简单。

数据类型
==========

整数
----------

int8,  byte  - 1字节，有符号整数  
int16, short - 2字节，有符号整数  
int32, int   - 4字节，有符号整数  
int64, long  - 8字节，有符号整数  

uint8,  ubyte  - 1字节，无符号整数  
uint16, ushort -   
uint32, uint   -  
uint64, ulong  -  

字符串
----------

字符串头部始终包含一个无符号整数类型的长度信息，空字符串的长度为0。  

string8, string  - 长度信息占用1个字节  
string16         - 长度信息占用2个字节  
string32         - 长度信息占用4个字节  
string64         - 长度信息占用8个字节  

列表
----------

列表头部包含一个无符号整数类型的列表长度信息，空列表的长度为0。  

list8, list  - 长度信息占用1个字节  
list16       - 长度信息占用2个字节  
list32       - 长度信息占用4个字节  
list64       - 长度信息占用8个字节  

列表后面必须紧跟列表元素的描述信息。  

示例 1:

    items : list
    {
        id : int,
        name : string
    }

枚举
----------

与C语言不一样，枚举声明必须有值和值类型  

示例 2:

    enum color : byte
    {
        red = 1, green = 2, blue = 3
    }

文档格式
==========

包和定义
----------

示例 3：

    pkg player = 1
    {
      enum login_state
      { 
        INIT    = 0,
        FAILED  = 1,
        SUCCEED = 2
      }

      def login_params = 0
      {
        user_name  : string,
        hash_code  : string,
        login_time : int
      }

      def login_result = 1
      {
        state : enum<login_state>
      }
    }

包可以嵌套定义，目的是更灵活的组织代码，比如登录接口有上下行数据，
按示例3那样分开声明没有问题，但是显得分散不利于阅读。可以尝试像示例4一样组织代码。

示例 4:

    pkg player = 1
    {
      pkg login
      {
        enum state
        { 
          INIT    = 0, 
          FAILED  = 1,
          SUCCEED = 2
        }

        def in = 0
        {
          user_name  : string,
          hash_code  : string,
          login_time : int
        }

        def out = 1
        {
          state : enum<state>
        }
      }
    }

具体的组织方式应该根据自身项目特点决定，并没有绝对的好坏。但是建议每个项目
只按一种规则书写BS代码，这是从工程化角度出发。

注释
----------

BS支持单行注释和多行注释，单行注释使用 // 起始，到行尾结束

多行注释使用 /* 起始，*/ 结束，多行注释不支持嵌套

